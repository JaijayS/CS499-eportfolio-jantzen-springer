# Enhancement Two: Algorithms and Data Structures

---

## ðŸ“¦ Clock Application

### 1. Artifact Overview

The **Clock application** was initially a **C++ program** created in **Spring 2023** that displays the current time in both 12-hour and 24-hour formats. In the console, a user could add time (seconds, minutes, hours) and it would update accordingly.

The enhanced version is a **JavaFX GUI application** featuring **start, stop, and reset controls** to manage the clock display. It was developed as a project to demonstrate **GUI programming** combined with **time-based algorithms**.

---

### 2. Justification for Inclusion

I selected this project because it highlights my ability to **refactor old, unstructured code** and apply more logical **data structures, algorithms, and event-driven flow**.

Key improvements include:
- Implementing **event-driven programming** and **JavaFX GUI**
- Adding **Timeline-based animation** to keep the clock ticking accurately
- Using **Java date/time APIs** and separating UI logic from business logic
- Implementing **asynchronous updates** and encapsulating state (hour, minute, second)

This project showcases my skills in:
- Real-time logic and algorithm design
- Synchronizing internal state with visual UI elements
- Object-oriented design principles with GUI architecture

---

### 3. Outcome Alignment

Yes, I met and extended the outcomes planned in Module One.

- The original **C++ implementation** demonstrated procedural logic and algorithm use for incrementing and displaying time.
- The **Java version** reimagined the application with a **tabbed interface** (clock and calculator), **event handlers**, and **Java collections/layouts** like `VBox`/`HBox`.

This transition reflects growth from **procedural** to **object-oriented design**, with more focus on usability and responsiveness.

---

### 4. Reflection

Creating the Clock application helped me:
- Understand **JavaFXâ€™s event model**
- Learn about **thread-safe UI updates**
- Use **Timeline** for real-time animation and accurate time tracking

One key challenge was maintaining accurate state over time and reflecting that state live in the UI. This process improved my understanding of separating concerns between UI components and logic layers.

---

## âž— Calculator Application

### 1. Artifact Overview

The **Calculator application** is a **Java console program** created in **2023** that performs basic arithmetic operations: **addition, subtraction, multiplication, and division**.

It focuses on core **algorithmic logic** and **expression evaluation**, demonstrating mastery of **control structures**, **operator precedence**, and **numeric input handling**. The project was originally written in **C++**.

---

### 2. Justification for Inclusion

I selected this project because it demonstrates my understanding of **algorithm design**, **expression parsing**, and applying **data structures** across languages.

The original C++ version focused on:
- **Formatted financial output**
- **Looping and control flow**
- **Function decomposition**

The Java version improved on this by:
- Abstracting the arithmetic logic into separate methods
- Improving flexibility and modularity
- Preparing for future GUI support

This reflects my ability to improve code structure and logic scalability.

---

### 3. Outcome Alignment

Yes, this enhancement met my algorithm/data structure goals.

- Implemented expression parsing and clean control flow
- Abstracted operations for maintainability
- Applied best practices in Java for input handling and arithmetic logic

I plan to extend this with **recursive algorithms**, **more advanced expressions**, and **a simple UI** to increase usability and robustness.

---

### 4. Reflection

This project reinforced my understanding of:
- Designing algorithms for numeric calculation
- Choosing appropriate data types and control structures
- Translating logic from C++ to Java in a modular, reusable way

I faced challenges ensuring consistent operator precedence and formatting output, especially when adapting the code across languages. It helped me develop cleaner patterns for evaluating input and handling errors.

---
